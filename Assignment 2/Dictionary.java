/**
 * Implements hashtable Dictionary
 * 
 * @author Mingpei Dou 251056543 CS2210A Coding Assignment 1
 *
 */
public class Dictionary implements DictionaryADT {
	// initial variables
	private LinkedHashList[] T; // initializes array T to store all values according to hash table
	private int size, entries = 0;

	/**
	 * method h
	 * 
	 * @param keyStr
	 * 
	 *               string to be converted into a polynomial hash value
	 * @return v
	 * 
	 *         polynomial hash value key
	 */
	private int h(String keyStr) { // hash function for array
		int v = keyStr.charAt(0); // initialize and declare hash value
		for (int i = 0; i < keyStr.length(); i++) // for every value to be entered into array
			v = (v * 15731 + (int) keyStr.charAt(i)) % size; // polynomial prime hash, avoids most collisions
		return v;
	}

	/**
	 * constructor for Dictionary
	 * 
	 * @param size
	 * 
	 *             size of the hash table
	 */
	public Dictionary(int size) { // initializes a dictionary with an empty hash table of the specified size
		this.size = size;
		T = new LinkedHashList[size]; // declare T
		for (int i = 0; i < size; i++) { // until T is full
			T[i] = new LinkedHashList(); // fill T with entries at every available node
		}
	}

	/**
	 * method put
	 * 
	 * @param record
	 * 
	 *               record to be placed in hash table
	 * @return collision
	 * 
	 *         number of collisions generated by hash function
	 */
	public int put(Data record) throws DuplicatedKeyException { // stores new data record in dictionary
		int pos = h(record.getKey()); // perform hash function
		int collision = 0;
		if (get(record.getKey()) == null) { // if record is in dictionary
			if (!T[pos].isEmpty()) { // if data entry is filled
				collision = 1; // throw collision
				T[pos].append(record); // separate chain to entry
			} else // if data entry is empty
				T[pos].append(record); // separate chain to entry
			entries++; // increase no. of entries
		} else
			throw new DuplicatedKeyException("key"); // return exception if record is not in dictionary
		return collision;
	}

	/**
	 * method remove
	 * 
	 * @param key
	 * 
	 *            key of node to remove
	 */
	public void remove(String key) throws InexistentKeyException { // removes pre-existing data record from dictionary
		int pos = h(key); // perform hash function
		if (get(key) != null) { // if key is in dictionary
			T[pos].remove(key); // remove key and decrease entries
			entries--;
		} else // if key not in dictionary, throw exception
			throw new InexistentKeyException("key");
	}

	/**
	 * method get
	 * 
	 * @param key
	 * 
	 *            key of node to find
	 * 
	 * @return p.getElem()
	 * 
	 *         Data element of requested node
	 */
	public Data get(String key) { // find data record if possible
		int pos = h(key); // perform hash function
		if (T[pos].isEmpty()) // if record does not exist, return null
			return null;
		HashNode p = T[pos].getHead();
		while (p != null && !p.getElem().getKey().equals(key)) // search list for entry until found
			p = p.getNext();
		if (p == null) // if record does not exist, return null
			return null;
		return p.getElem();
	}

	/**
	 * method numDataItems
	 * 
	 * @return entries
	 * 
	 *         number of entries in hash table
	 */
	public int numDataItems() { // return number of entries in dictionary
		return entries;
	}

}
